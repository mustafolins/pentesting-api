using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PentestingCommon
{
    public class PersistentShell
    {
        public Process Process { get; set; }
        public StringBuilder CurrentOutput { get; set; }
        public StringBuilder CurrentInput { get; set; }
        public int WaitTime { get; set; } = 1;
        public Stopwatch TimeSinceLastOutput { get; set; } = new Stopwatch();

        public PersistentShell()
        {
            SetupShell();
            // setup output/error reader
            Process.OutputDataReceived += Process_OutputDataReceived;
            Process.ErrorDataReceived += Process_ErrorDataReceived;
            // start the shell
            Start();
        }

        /// <summary>
        /// Initializes the persistent shell with the given <paramref name="outputRecieved"/> and <paramref name="errorRecieved"/> event handlers.
        /// </summary>
        /// <param name="outputRecieved">The output event handler to use for output events.</param>
        /// <param name="errorRecieved">The error event handler to use for error events.</param>
        public PersistentShell(DataReceivedEventHandler outputRecieved, DataReceivedEventHandler errorRecieved)
        {
            SetupShell();
            // setup output/error reader
            Process.OutputDataReceived += outputRecieved;
            Process.ErrorDataReceived += errorRecieved;
            // start the shell
            Start();
        }

        /// <summary>
        /// Sets the persistent shell up.
        /// </summary>
        private void SetupShell()
        {
            // initialize string builder
            CurrentOutput = new StringBuilder();
            CurrentInput = new StringBuilder();
            // set up start info
            var startInfo = new ProcessStartInfo
            {
                //WindowStyle = ProcessWindowStyle.Hidden,
                FileName = "cmd.exe",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                RedirectStandardInput = true,
                CreateNoWindow = true
            };
            // set up process
            Process = new Process
            {
                StartInfo = startInfo
            };
        }

        /// <summary>
        /// Starts the persistent shell.
        /// </summary>
        private void Start()
        {
            // start the process
            Process.Start();
            Process.BeginOutputReadLine();
            Process.BeginErrorReadLine();
        }

        /// <summary>
        /// Writes the <paramref name="stdInput"/> to the shell.
        /// </summary>
        /// <param name="stdInput">The <see cref="StandardInputObject"/> that contents input to write to shell.</param>
        public void Write(StandardInputObject stdInput)
        {
            // don't write content if it is null, if it's just empty consider that an empty line
            if (stdInput.Input == null)
            {
                return;
            }

            // clear input and output
            CurrentOutput.Clear();
            CurrentInput.Clear();
            // send recieved input to standard input
            CurrentInput.AppendLine(stdInput.Input);
            Process.StandardInput.WriteLine(CurrentInput);
        }

        /// <summary>
        /// Wait for the <seealso cref="Process"/> to finish current execution.
        /// </summary>
        /// <returns>The standard output of the <seealso cref="Process"/></returns>
        public async Task<string> WaitForShellOutput()
        {
            // wait for time since last output to be greater than set wait time
            TimeSinceLastOutput.Start();
            while (TimeSinceLastOutput.ElapsedMilliseconds < WaitTime * 1_000 || IsNotWaitingForInput())
            {
                await Task.Delay(10);
            }
            return CurrentOutput.ToString();
        }

        /// <summary>
        /// Gets a <see cref="bool"/> indicating if the <seealso cref="Process"/> is not waiting for input.
        /// </summary>
        /// <returns>True if not waiting, False otherwise.</returns>
        public bool IsNotWaitingForInput()
        {
            return CurrentOutput.Length == 0;
        }

        /// <summary>
        /// Processes output data from <seealso cref="Process"/> when it comes in.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Process_OutputDataReceived(object sender, DataReceivedEventArgs e)
        {
            if (e.Data != null)
            {
                CurrentOutput.AppendLine(e.Data);
                TimeSinceLastOutput.Restart();
            }
        }

        /// <summary>
        /// Processes error data from <seealso cref="Process"/> when it comes in.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Process_ErrorDataReceived(object sender, DataReceivedEventArgs e)
        {
            if (e.Data != null)
            {
                CurrentOutput.AppendLine(e.Data);
                TimeSinceLastOutput.Restart();
            }
        }
    }
}
